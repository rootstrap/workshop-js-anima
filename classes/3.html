<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>JS workshop</title>

  <link rel="stylesheet" href="../reveal.js/dist/reset.css">
  <link rel="stylesheet" href="../reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="../reveal.js/dist/theme/black.css" id="theme">

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css" id="highlight-theme">
</head>

<body>

  <div class="reveal">
    <div class="slides">
      <!-- Title -->
      <section>
        <h1>JavaScript asincrónico</h1>
      </section>

        <!-- Schedule -->
        <section>
          <h3>Agenda</h3>
          <ol>
            <li>Repaso de JS basico</li>
            <li>¿Que es asincronía?</li>
            <li>Funciones callback</li>
            <li><code>setTimeout</code> y <code>setInterval</code></li>
            <li>AJAX, XHR</li>
            <li>Promesas y API <code>fetch</code></li>
            <li><code>async</code> / <code>await</code></li>
          </ol>
        </section>
        
        <!-- Repaso -->
        <section>
          <h3>Repaso</h3>
          <section>Recap slide 1</section>
          <section>Recap slide 2</section>
        </section>

        <!-- Intro a asincronía -->
        <section>
          <h3>¿Que es asincronía?</h3>
          <section>
            <p>
              Para entender asincronía en JavaScript, primero tengamos claro lo opuesto
            </p>
            <p>
              Cambiemos momentáneamente la pregunta: ¿Qué es JavaScript síncrono?
            </p>
          </section>
          <section>
            Lo que han visto hasta ahora, es todo código síncrono. La ejecución se realiza en orden. Una
            sentencia se ejecuta una vez que la anterior finaliza, de arriba a abajo.
            <pre><code data-trim data-line-numbers class="lang-javascript">
              console.log('Primer salida a consola');
              console.log('Segunda salida a consola');
          </code></pre>
          </section>
          <section>
            <img src="../assets/syncVsAsync.png" alt="">
          </section>
          <section>
            <p>
              Ejecutar código de manera síncrona nos impone algunas limitantes con operaciones lentas, costosas o ejecutadas por terceros. Veamos el
              siguiente código.
            </p>
            <pre><code data-trim data-line-numbers="1|2|3-9|4-6|7-9">
                const btn = document.querySelector('button');
                btn.addEventListener('click', function () {
                  let fecha;
                  for (let i = 0; i < 10000000; i++) {
                    fecha = new Date();
                  }
                  let pElem = document.createElement('p');
                  pElem.textContent = fecha;
                  document.body.appendChild(pElem);
                });
            </code></pre>
            <iframe data-src="../ejemplos/async/blocking.html" height="100px" width="800px"> </iframe>
            <aside class="notes">
              <p>
                El codigo que vemos acá corre sobre un html con un botón. En la primer linea vemos
                con lo selecciona y en la segunda se agrega un listener para el evento click. La
                función que se define entre las lineas 3 y 8 corre una vez se haga click al botón.
              </p>
              <p>
                Lo que hace esta función es: primero obtiene una fecha y la muestra por consola.
                Luego calcula 20 millones de veces la fecha, y la muestra nuevamente por consola. El
                ejemplo es claramente ridículo, pero demuestra como una operación que consume mucho
                tiempo, inhabilita el navegador.
              </p>
              <p>
                Mientras se ejecuta el loop, el control queda allí y no es devuelto al navegador
                para continuar actualizando la pantalla o continuar ejecutando código. A esto se le
                llama "código bloqueante".
              </p>
            </aside>
          </section>
          <section>
            Para evitar el código bloqueante, para por ejemplo, no congelar el navegador mientras
            pedimos información a un servidor, hacemos uso de código que corre de forma asíncrona.
          </section>
        </section>

      <!-- Callbacks -->
      <section>
        <h3>Callbacks</h3>
        <section>
          Una función callback es aquella que es pasada por parámetro a otra función, para luego ser invocada
          internamente.
          <pre><code data-trim data-line-numbers class="lang-javascript">
            function greeting(name) {
              alert('Hola ' + name);
            };

            function processUserInput(callback) {
              var name = prompt('Por favor ingresa tu nombre');
              callback(name);
            };

            processUserInput(greeting);
          </code></pre>
          <aside class="notes">
            Al utilizar la palabra reservada function, podemos declarar funciones, pero éstas no son invocadas en ese momento sino que se deben invocar de manera manual utilizando el nombre de la función declarada y agregandole los parámetros entre paréntesis (o paréntesis vacíos si no espera parámetros ej: nombreFuncion()).
            <br>
            Notar en el ejemplo que la función processUserInput recibe greeting sin los paréntesis, es decir que no la estamos invocando.
          </aside>
        </section>
        <section>
          Podemos manejar eventos del DOM utilizando callbacks.
          <pre><code data-trim data-line-numbers class="lang-javascript">
            function callback(event) {
              event.preventDefault();
              console.log("El usuario hizo click en el botón!");
            };

            const button = document.queryselector("#callback-btn")
            
            button.addEventListener("click", callback);
          </code></pre>

          <aside class="notes">
            Al manejar eventos del DOM utilizando la API document, la función que utilizamos como callback siempre recibe como parámetro el evento que está manejando, el cuál en este caso es el click.
            <br>
            En nuestra función podemos interacutar con ese evento para por ejemplo evitar una redirección u obtener el elemento que lanzó el evento.
          </aside>
        </section>
      </section>

      <!-- setTimeout - setInterval -->
      <section>
        <section>
          <h3>setTimeout - setInterval</h3>
          Son funciones que nos provee JavaScript y nos permiten ejecutar funciones de manera asincrónica. Ambas reciben por parámetro la función (callback) que deben ejecutar.
        </section>
        <section>
          <h3>setTimeout</h3>
          Recibe como primer parámetro la función callback, y como segundo parámetro el tiempo que debe esperar para realizar la invocación a la función (expresado en milisegundos).
          <pre><code data-trim data-line-numbers class="lang-javascript">
            function myFunction() {
              console.log("Han pasado 3 segundos!");
            };

            setTimeout(myFunction, 3000);
          </code></pre>
          <aside class="notes">
            La función callback es invocada una única vez, al transcurrir el tiempo especificado.
          </aside>
        </section>
        <section>
          <h3>setInterval</h3>
          Recibe como primer parámetro la función callback, y como segundo parámetro el tiempo que debe esperar entre cada invocación a la función (expresado en milisegundos).
          <pre><code data-trim data-line-numbers class="lang-javascript">
            let counter = 0;
            function incrementCounter() {
              counter = counter + 1;
              console.log('Esta función se ejecutó ' + counter + ' veces!');
            };

            setInterval(incrementCounter, 1000);
          </code></pre>
          <aside class="notes">
            A diferencia del setTimeout, setInterval continúa invocando a la función callback cada vez que se transcurre el tiempo especificado (en este caso 3 segundos)
          </aside>
        </section>
        <section>
          <h3>setTimeout - setInterval</h3>
          Puede suceder que necesitemos que nuestro timer no se siga ejecutando. Para ello podemos utilizar la función <b>clearTimeout</b> o <b>clearInterval</b>.
          <pre><code data-trim data-line-numbers class="lang-javascript">
            let counter = 0;
            let timer;

            function incrementCounter() {
              counter = counter + 1;
              checkCount();
            };

            function checkCount() {
              if (counter == 10) {
                clearInterval(timer);
              };
            };

            timer = setInterval(incrementCounter, 1000);
          </code></pre>
          <aside class="notes">
            En el ejemplo las variables counter y timer son definidas antes de las funciones. Esto es para que su scope (alcence) permite utilizarlas tanto dentro como fuera de las funciones.
          </aside>
        </section>
      </section>
      
      <!-- AJAX y XHR -->
      <section>
        <section>
          <h3>AJAX</h3>
          Es una técnica utilizada para poder cambiar contenido dinámicamente en una aplicación web. El contenido es modificado sin necesidad de recargar la página o interrumpir su comportamiento.
        </section>
        <section>
          Esto se realiza pidiendo datos a un servidor asincrónicamente. Cuando el servidor responde con los datos solicitados, se utiliza Javascript para modificar el contenido con esta nueva información.
        </section>
        <section>
          <h3>XHR</h3>
          Se utiliza XHR (sigla para <a href="https://developer.mozilla.org/es/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a>) para ejecutar AJAX en páginas web. 
          <br> --- <br>
          <a target="_blank" href="https://codesandbox.io/s/restless-glade-jhwe4">CodeSandbox</a>
        </section>
        <section>
          <h3>XHR</h3>
          Request AJAX utilizando método 'GET'
          <pre><code data-trim data-line-numbers class="lang-javascript">
            const xhr = new XMLHttpRequest();
            xhr.open(
              "GET",
              "https://gist.githubusercontent.com/spereztoledo/d7740ac1ad1212ce8810c5c809d7acd3/raw/d57477f19d8e173b8671ffff9494db75e246d4e7/quotes.json"
            );
          
            // Callback para cambio de estado en el request
            xhr.onreadystatechange = function () {
              let DONE = 4; // readyState 4 => el request esta pronto.
              let OK = 200; // status 200 => retorno exitoso.
              if (xhr.readyState === DONE) {
                if (xhr.status === OK) {
                  // convertir respuesta a JSON 
                  // ya que xhr solo responde texto o XML
                  const response = JSON.parse(xhr.responseText);
                  console.log(response);
                } else {
                  // Ocurrió un error durante el request.
                  console.log("Error: " + xhr.status); 
                }
              }
            };
          
            // Enviar el request hacia quotes.json
            xhr.send();
          </code></pre>
        </section>
      </section>
      <!-- Promesas y fetch API -->
      <section>
        <h3>Promesas</h3>
        <section>
          Una <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promise">promesa</a> es un objeto que representa el estado de una operación asíncrona. El navegador nos promete retornar una respuesta cuando la reciba, si la recibe
        </section>
        <section>
          <h3> Estados de una promesa</h3>
            <h4 style="color:blue">pending</h4>
            <p>Estado inicial, ni completada ni rechazada</p>
            <h4 style="color:green">fulfilled</h4>
            <p>Completada satisfactoriamente, retornando un valor</p>
            <h4 style="color:red">rejected</h4>
            <p>La operación falló, retornando un error</p>
        </section>
        <section>
          <p>Para usar una promesa, se encadenan metodos, que ejecutarán callbacks según lo que suceda con la respuesta. Estos callbacks recibirán los datos que podemos manejar dentro de estas funciones. Los metodos son:</p>
          <ul>
            <li><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promise/then">then</a></li>
            <li><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promise/catch">catch</a></li>
            <li><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promise/finally">finally</a></li>
          </ul>
        </section>
        <section>
          Un buen ejemplo de uso de promesas es la API <a href="https://developer.mozilla.org/es/docs/Web/API/Fetch_API">fetch</a>. Esta facilita el manejo de peticiones y respuestas a un servidor, en comparación con XHR.
          <pre><code data-trim data-line-numbers="1|2|3|7|8|9|10|11|1-12" class="lang-javascript">
            const promesa = fetch("https://api.ejemplo.com/datos");
            promesa.then(function (data) {
                return data.json();
            }).then(function (json){
                console.log(json);
            }).catch(function (error) {
                console.log("Error:" + error); 
            }).finally(function (){
                console.log('Fin de ejecución de fetch');
            });
          </code></pre>
        </section>
      </section>
      <section>
        <h3>async / await</h3>
        <section>
          <p>
            Declarar funciones como <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Sentencias/funcion_asincrona">async</a> nos permite usar una santaxis más simple para utilizar promesas, habilitandonos el uso de la palabra clave <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Operadores/await">await</a>. 
          </p>
          <p>
            El código luce como si fuera síncrono!
          </p>
        </section>
        <section>
          Reescribamos esta funcion con promesas usando async/await
          <div class="fragment" data-fragment-index=0>
            <pre><code data-trim data-line-numbers= class="lang-javascript">
              function obtenerDatos() {
                const promesa = fetch("https://api.com/datos");
                promesa.then(function (respuesta) {
                    return respuesta.json();
                }).then(function (data){
                    console.log(data);
                })
              }
            </code></pre>
          </div>
          <div class="fragment" data-fragment-index=4>
            <pre><code data-trim data-line-numbers class="lang-javascript">
              async function obtenerDatos() {
                const respuesta = await fetch("https://api.com/datos");
                const data = await respuesta.json();
                console.log(data);
              }
            </code></pre>
          </div>
        </section>
      </section>
    </div>
  </div>

  <script src="../reveal.js/dist/reveal.js"></script>
  <script src="../reveal.js/plugin/notes/notes.js"></script>
  <script src="../reveal.js/plugin/markdown/markdown.js"></script>
  <script src="../reveal.js/plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>