<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>JS workshop</title>

  <link rel="stylesheet" href="../reveal.js/dist/reset.css">
  <link rel="stylesheet" href="../reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="../reveal.js/dist/theme/black.css" id="theme">

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css" id="highlight-theme">
</head>

<body>

  <div class="reveal">
    <div class="slides">
      <!-- Title -->
      <section>
        <h1>JavaScript asincrónico</h1>
      </section>

        <!-- Schedule -->
        <section>
          <h3>Agenda</h3>
          <ol>
            <li>Repaso de JS basico</li>
            <li>¿Que es asincronía?</li>
            <li>Funciones callback</li>
            <li><code>setTimeout</code> y <code>setInterval</code></li>
            <li>AJAX, XHR</li>
            <li>Promesas y API <code>fetch</code></li>
            <li><code>async</code> / <code>await</code></li>
          </ol>
        </section>
        
        <!-- Repaso -->
        <section>
          <h3>Repaso</h3>
          <section>Recap slide 1</section>
          <section>Recap slide 2</section>
        </section>

        <!-- Intro a asincronía -->
        <section>
          <h3>¿Que es asincronía?</h3>
          <section>
            <p>
              Para entender asincronía en JavaScript, primero tengamos claro lo opuesto
            </p>
            <p>
              Cambiemos momentáneamente la pregunta: ¿Qué es JavaScript síncrono?
            </p>
          </section>
          <section>
            Lo que han visto hasta ahora, es todo código síncrono. La ejecución se realiza en orden. Una
            sentencia se ejecuta una vez que la anterior finaliza, de arriba a abajo.
            <pre><code data-trim data-line-numbers class="lang-javascript">
              console.log('Primer salida a consola');
              console.log('Segunda salida a consola');
          </code></pre>
          </section>
          <section>
            <img src="../assets/syncVsAsync.png" alt="">
          </section>
          <section>
            <p>
              Ejecutar código de manera síncrona nos impone algunas limitantes con operaciones lentas, costosas o ejecutadas por terceros. Veamos el
              siguiente código.
            </p>
            <pre><code data-trim data-line-numbers="1|2|3-9|4-6|7-9">
                const btn = document.querySelector('button');
                btn.addEventListener('click', function () {
                  let fecha;
                  for (let i = 0; i < 10000000; i++) {
                    fecha = new Date();
                  }
                  let pElem = document.createElement('p');
                  pElem.textContent = fecha;
                  document.body.appendChild(pElem);
                });
            </code></pre>
            <iframe data-src="../ejemplos/async/blocking.html" height="100px" width="800px"> </iframe>
            <aside class="notes">
              <p>
                El código que vemos acá corre sobre un html con un botón. En la primer linea vemos
                que lo selecciona y en la segunda se agrega un manejador para el evento click. La
                función que se define entre las líneas 3 y 8 corre una vez se haga click al botón.
              </p>
              <p>
                Lo que hace esta función es: primero obtiene una fecha y la muestra por consola.
                Luego calcula 10 millones de veces la fecha, y la muestra nuevamente por consola. El
                ejemplo es claramente ridículo, pero demuestra como una operación que consume mucho
                tiempo, inhabilita el navegador.
              </p>
              <p>
                Mientras se ejecuta el loop, el control queda allí y no es devuelto al navegador
                para continuar actualizando la pantalla o continuar ejecutando código. A esto se le
                llama "código bloqueante".
              </p>
            </aside>
          </section>
          <section>
            Para evitar el código bloqueante, por ejemplo para no congelar el navegador mientras
            pedimos información a un servidor, hacemos uso de código que corre de forma asíncrona.
          </section>
        </section>

      <!-- Callbacks -->
      <section>
        <h3>Callbacks</h3>
        <section>
          Una función callback es aquella que es pasada por parámetro a otra función, para luego ser invocada
          internamente.
          <pre><code data-trim data-line-numbers class="lang-javascript">
            function greeting(name) {
              alert('Hola ' + name);
            };

            function processUserInput(callback) {
              var name = prompt('Por favor ingresa tu nombre');
              callback(name);
            };

            processUserInput(greeting);
          </code></pre>
          <aside class="notes">
            Al utilizar la palabra reservada function, podemos declarar funciones, pero éstas no son invocadas en ese momento sino que se deben invocar de manera manual utilizando el nombre de la función declarada y agregandole los parámetros entre paréntesis (o paréntesis vacíos si no espera parámetros ej: nombreFuncion()).
            <br>
            Notar en el ejemplo que la función processUserInput recibe greeting sin los paréntesis, es decir que no la estamos invocando.
          </aside>
        </section>
        <section>
          Podemos manejar eventos del DOM utilizando callbacks.
          <pre><code data-trim data-line-numbers class="lang-javascript">
            function callback(event) {
              event.preventDefault();
              console.log("El usuario hizo click en el botón!");
            };

            const button = document.queryselector("#callback-btn")
            
            button.addEventListener("click", callback);
          </code></pre>

          <aside class="notes">
            Al manejar eventos del DOM utilizando la API document, la función que utilizamos como callback siempre recibe como parámetro el evento que está manejando, el cuál en este caso es el click.
            <br>
            En nuestra función podemos interacutar con ese evento para por ejemplo evitar una redirección u obtener el elemento que lanzó el evento.
          </aside>
        </section>
      </section>

      <!-- setTimeout - setInterval -->
      <section>
        <section>
          <h3>setTimeout - setInterval</h3>
          Son funciones que nos provee JavaScript y nos permiten ejecutar funciones de manera asincrónica. Ambas reciben por parámetro la función (callback) que deben ejecutar.
        </section>
        <section>
          <h3>setTimeout</h3>
          Recibe como primer parámetro la función callback, y como segundo parámetro el tiempo que debe esperar para realizar la invocación a la función (expresado en milisegundos).
          <pre><code data-trim data-line-numbers class="lang-javascript">
            function myFunction() {
              console.log("Han pasado 3 segundos!");
            };

            setTimeout(myFunction, 3000);
          </code></pre>
          <aside class="notes">
            La función callback es invocada una única vez, al transcurrir el tiempo especificado.
          </aside>
        </section>
        <section>
          <h3>setInterval</h3>
          Recibe como primer parámetro la función callback, y como segundo parámetro el tiempo que debe esperar entre cada invocación a la función (expresado en milisegundos).
          <pre><code data-trim data-line-numbers class="lang-javascript">
            let counter = 0;
            function incrementCounter() {
              counter = counter + 1;
              console.log('Esta función se ejecutó ' + counter + ' veces!');
            };

            setInterval(incrementCounter, 1000);
          </code></pre>
          <aside class="notes">
            A diferencia del setTimeout, setInterval continúa invocando a la función callback cada vez que se transcurre el tiempo especificado (en este caso 3 segundos)
          </aside>
        </section>
        <section>
          <h3>setTimeout - setInterval</h3>
          Puede suceder que necesitemos que nuestro timer no se siga ejecutando. Para ello podemos utilizar la función <b>clearTimeout</b> o <b>clearInterval</b>.
          <pre><code data-trim data-line-numbers class="lang-javascript">
            let counter = 0;
            let timer;

            function incrementCounter() {
              counter = counter + 1;
              checkCount();
            };

            function checkCount() {
              if (counter == 10) {
                clearInterval(timer);
              };
            };

            timer = setInterval(incrementCounter, 1000);
          </code></pre>
          <aside class="notes">
            En el ejemplo las variables counter y timer son definidas antes de las funciones. Esto es para que su scope (alcence) permite utilizarlas tanto dentro como fuera de las funciones.
          </aside>
        </section>
      </section>
      
      <!-- AJAX y XHR -->
      <section>
        <section>
          <h3>AJAX</h3>
          Es una técnica utilizada para poder cambiar contenido dinámicamente en una aplicación web. El contenido es modificado sin necesidad de recargar la página o interrumpir su comportamiento.
        </section>
        <section>
          Esto se realiza pidiendo datos a un servidor asincrónicamente. Cuando el servidor responde con los datos solicitados, se utiliza Javascript para modificar el contenido con esta nueva información.
        </section>
        <section>
          <h3>XHR</h3>
          Se utiliza XHR (sigla para <a href="https://developer.mozilla.org/es/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a>) para ejecutar AJAX en páginas web. 
          <br> --- <br>
          <a target="_blank" href="https://codesandbox.io/s/restless-glade-jhwe4">CodeSandbox</a>
          <aside class="notes">
            Vamos a ver esto muy brevemente y sin mucho enfasis, dado que es una manera ya no muy utilizada de hacer requests a un server. En la práctica, esto está abstraído y su uso facilitado por una librería, o se utiliza una nueva API que provéen los navegadores modernos.
          </aside>
        </section>
        <section>
          <h3>XHR</h3>
          Request AJAX utilizando método 'GET'
          <pre><code data-trim data-line-numbers="1|2|4-9|11-14|16-17" class="lang-javascript">
            const xhr = new XMLHttpRequest();
            xhr.open('GET', 'https://api.com/datos');
          
            // Callback al finalizar correctamente
            xhr.onload = function () {
              // convertir respuesta a JSON a partir del texto
              const response = JSON.parse(xhr.responseText);
              console.log(response);
            }

            // Callback de error en el request.
            xhr.onerror = function () {
              console.log('Error: ' + xhr.statusText); 
            };
          
            // Enviar el request hacia el servidor
            xhr.send();
          </code></pre>
          <aside class="notes">
            <p>
              En la primera línea, generamos un nuevo objeto XHR, que nos permite generar un request. En la línea 2, usamos el método open, al que le pasaremos 2 parámetros. El primero siendo el método HTTP, en este caso un GET para obtener información, pero funciona de forma similar con otros como POST y PUT.
            </p>
            <p>
              Entre las líneas 5 y 9, adjuntamos nuestro callback onload para ser ejecutado cuando tengamos una respuesta satisfactoria. La respuesta estará disponible dentro del objeto xhr, en la propiedad responseText. Parseamos ese objeto, para obtener un objeto javascript y utilizarlo en nuestro código.
            </p>
            <p>
              Entre las líneas 12 y 14, adjuntamos nuestro callback onerror para ser ejecutado cuando tengamos una respuesta de error. El código HTTP de la respuesta es lo que mostramos en este caso. El tipo de error y lo que envíe el servidor en response puede ayudarnos a saber que sucedió, pero el status lo tendremos siempre.
            </p>
            <p>
              Por último, en la línea 17, ejecutamos el método send, que envía el request al servidor, y quedamos a la espera de una respuesta, sabiendo que al tenerla se ejecutará el callback adecuado.
            </p>
          </aside>
        </section>
      </section>
      <!-- Promesas y fetch API -->
      <section>
        <h3>Promesas</h3>
        <section>
          Una <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promise">promesa</a> es un objeto que representa el estado de una operación asíncrona. El navegador nos promete retornar una respuesta cuando la reciba, si la recibe
        </section>
         <section>
          <img src="../assets/promisesDiagram.png" alt="">
          <aside class="notes">
            Como ven en el diagrama, una promesa tiene diferentes estados. Al cambiar de estado, se ejecutarán los métodos asociados, que dispararán callbacks que definiremos de antemano para cada uno de estos métodos.
          </aside>
        </section>
        <section>
            <img style="max-width: 80%;" src="../assets/promisesFullDiagram.png" alt="">
            <aside class="notes">
              <p>
                Los 3 estados de una promesa son los que ven allí. Pending es el estado inicial, y el que tendremos mientras no se concrete una respuesta. De cualminar con éxito, pasará al estado fulfilled (o cumplida en español), y de haber algún error, al estado rejected (o rechazada en español)
              </p>.
              <p>
                Como decíamos antes, cada uno de estos estados, salvo el pending, tiene asociados al menos un método. Cuando la promesa se cumple, se ejecuta el método then, que va a disparar el callback de éxito que le hayamos asociado. Todo esto lo tendremos ya definido. A este callback se la pasará como parámetro los datos de la promesa resuelta, para que podamos utilizarlos. 
              </p>
              <p>
                De manera similar pasa cuando la promesa es rechazada. Se dispara el método catch, que ejecutará nuestro callback de error. Este callback de error tendrá también un parámetro, que tendrá información sobre el error, que puede ser útil para recuperarse de él, reintentar o comunicar el error al usuario.
              </p>
              <p>
                Existe un tercer método, llamado finally, que no está en el diagrama simplemente para no complicarlo, pero que se va a ejecutar cuando la promesa se cumpla o se rechace, y será luego del metodo then o catch, segun lo que suceda. Este tiene asociado su propio callback.
              </p>
            </aside>
       </section>
        <section>
          <p>Para usar una promesa, asociamos callbacks a los métodos disponibles. Al cambiar el estado de la promesa, se ejecutarán  los callbacks correspondientes.</p>
          <p>Estos callbacks se invocarán con los datos buscados o información sobre el error ocurrido como parámetros</p>
          <p>Los métodos son:</p>
          <ul>
            <li><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promise/then">then</a></li>
            <li><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promise/catch">catch</a></li>
            <li><a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promise/finally">finally</a></li>
          </ul>
        </section>
        <section>
          <p>Estos metodos pueden a su vez encadenarse, dado que retornan a su vez promesas. Los callbacks sobre estos métodos, pueden retornar valores y estarán disponibles para los siguientes en la cadena.
          </p>
          <p>
            Lo retornado por estos callbacks, estarán disponibles para los siguientes métodos en la cadena. </p>
        </section>
        
        <section>
          Un buen ejemplo de uso de promesas es la API <a href="https://developer.mozilla.org/es/docs/Web/API/Fetch_API">fetch</a>. Esta facilita el manejo de peticiones y respuestas a un servidor, en comparación con XHR.
          <pre><code data-trim data-line-numbers="1|2|3|5|6|7|8|9|10|11|1-12" class="lang-javascript">
            const promesa = fetch("https://api.ejemplo.com/datos");
            promesa.then(function (respuesta) {
                return respuesta.json();
            }).then(function (json){
                console.log(json);
            }).catch(function (error) {
                console.log("Error:" + error); 
            }).finally(function (){
                console.log('Fin de ejecución de fetch');
            });
          </code></pre>
          <aside>
            <p>
              Veamos un ejemplo que seguro dejará todo un poco más claro y repasamos un poco lo que veniamos hablando. En la primera linea, usamos el método fetch, que nos va a devolver una promesa que guardamos en la constante promesa. La api fetch para hacer un get solo necesita la URL. El uso sería similar para otras funciones que retornan promesas, las podemos guardar en constantes o variables como cualquier otro objeto.
            </p>>
            <p>
              En la línea 2, encadenamos el método then, y entre paréntesis pasamos nuestra función callback. Como ven, toma un parámetro respuesta, donde tendremos la respuesta que nos retorne fetch. La respuesta tiene más información que solo los datos, pero nos brinda un método json para darnos los datos directamente. La particularidad de este metodo json es que devuelve una promesa. Como los métodos then son encadenables, el siguiente método then en la cadena, que tiene su declaración de callback en la linea 4, recibirá los datos contenidos en esa segunda promesa cuando se resuelva, que son los datos que buscamos. Y en la línea 5 los mostramos por consola.
            </p>
            <p>
              En la línea 6, encadenamos nuestro método catch, para capturar algún error que pueda darse en la cadena, y tenemos el parámetro error donde tendremos mayor información del error.
            </p>
            <p>
              Por último, tenemos el método finally, que como les contaba, se va a ejecutar una vez que tengamos una respuesta, con o sin erorr, con la diferencia de que finally no recibe ningún parámetro.
            </p>
          </aside>
        </section>
      </section>
      <section>
        <h3>async / await</h3>
        <section>
          <p>
            Declarar funciones como <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Sentencias/funcion_asincrona">async</a> nos permite usar una sintaxis más simple para utilizar promesas, habilitándonos el uso de la palabra clave <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Operadores/await">await</a>. 
          </p>
          <p>
            El código luce como si fuera síncrono!
          </p>
        </section>
        <section>
          Reescribamos esta función con promesas usando async/await
          <div class="fragment" data-fragment-index=0>
            <pre><code data-trim data-line-numbers= class="lang-javascript">
              function obtenerDatos() {
                const promesa = fetch("https://api.com/datos");
                promesa.then(function (respuesta) {
                    return respuesta.json();
                }).then(function (data){
                    console.log(data);
                })
              }
            </code></pre>
          </div>
          <div class="fragment" data-fragment-index=4>
            <pre><code data-trim data-line-numbers class="lang-javascript">
              async function obtenerDatos() {
                const respuesta = await fetch("https://api.com/datos");
                const data = await respuesta.json();
                console.log(data);
              }
            </code></pre>
          </div>
        </section>
      </section>
    </div>
  </div>

  <script src="../reveal.js/dist/reveal.js"></script>
  <script src="../reveal.js/plugin/notes/notes.js"></script>
  <script src="../reveal.js/plugin/markdown/markdown.js"></script>
  <script src="../reveal.js/plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>
