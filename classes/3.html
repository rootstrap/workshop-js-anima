<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>JS workshop</title>

  <link rel="stylesheet" href="../reveal.js/dist/reset.css">
  <link rel="stylesheet" href="../reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="../reveal.js/dist/theme/black.css" id="theme">

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css" id="highlight-theme">
</head>

<body>

  <div class="reveal">
    <div class="slides">
      <!-- Title -->
      <section>
        <h1>JavaScript asincrónico</h1>
      </section>

      <!-- Schedule -->
      <section>
        <h3>Agenda</h3>
        <ol>
          <li>
            Funciones callback
          </li>
          <li>
            setTimeout - setInterval
          </li>
          <li>
            <!-- Maybe fetch API should be after promises -->
            AJAX, XHR y API fetch
          </li>
          <li>
            Promesas
          </li>
          <li>
            Async/await
          </li>
        </ol>
      </section>

      <!-- Callbacks -->
      <section>
        <h3>Callbacks</h3>
        <section>
          Una función callback es aquella que es pasada por parámetro a otra función, para luego ser invocada
          internamente.
          <pre><code data-trim class="lang-javascript">
            function greeting(name) {
              alert('Hola ' + name);
            };

            function processUserInput(callback) {
              var name = prompt('Por favor ingresa tu nombre');
              callback(name);
            };

            processUserInput(greeting);
          </code></pre>
          <aside class="notes">
            Al utilizar la palabra reservada function, podemos declarar funciones, pero éstas no son invocadas en ese momento sino que se deben invocar de manera manual utilizando el nombre de la función declarada y agregandole los parámetros entre paréntesis (o paréntesis vacíos si no espera parámetros ej: nombreFuncion()).
            <br>
            Notar en el ejemplo que la función processUserInput recibe greeting sin los paréntesis, es decir que no la estamos invocando.
          </aside>
        </section>
        <section>
          Podemos manejar eventos del DOM utilizando callbacks.
          <pre><code data-trim class="lang-javascript">
            function callback(event) {
              event.preventDefault();
              console.log("El usuario hizo click en el botón!");
            };

            const button = document.queryselector("#callback-btn")
            
            button.addEventListener("click", callback);
          </code></pre>

          <aside class="notes">
            Al manejar eventos del DOM utilizando la API document, la función que utilizamos como callback siempre recibe como parámetro el evento que está manejando, el cuál en este caso es el click.
            <br>
            En nuestra función podemos interacutar con ese evento para por ejemplo evitar una redirección u obtener el elemento que lanzó el evento.
          </aside>
        </section>
      </section>

      <!-- setTimeout - setInterval -->
      <section>
        <section>
          <h3>setTimeout - setInterval</h3>
          Son funciones que nos provee JavaScript y nos permiten ejecutar funciones de manera asincrónica. Ambas reciben por parámetro la función (callback) que deben ejecutar.
        </section>
        <section>
          <h3>setTimeout</h3>
          Recibe como primer parámetro la función callback, y como segundo parámetro el tiempo que debe esperar para realizar la invocación a la función (expresado en milisegundos).
          <pre><code data-trim class="lang-javascript">
            function myFunction() {
              console.log("Han pasado 3 segundos!");
            };

            setTimeout(myFunction, 3000);
          </code></pre>
          <aside class="notes">
            La función callback es invocada una única vez, al transcurrir el tiempo especificado.
          </aside>
        </section>
        <section>
          <h3>setInterval</h3>
          Recibe como primer parámetro la función callback, y como segundo parámetro el tiempo que debe esperar entre cada invocación a la función (expresado en milisegundos).
          <pre><code data-trim class="lang-javascript">
            let counter = 0;
            function incrementCounter() {
              counter = counter + 1;
              console.log('Esta función se ejecutó ' + counter + ' veces!');
            };

            setInterval(incrementCounter, 1000);
          </code></pre>
          <aside class="notes">
            A diferencia del setTimeout, setInterval continúa invocando a la función callback cada vez que se transcurre el tiempo especificado (en este caso 3 segundos)
          </aside>
        </section>
        <section>
          <h3>setTimeout - setInterval</h3>
          Puede suceder que necesitemos que nuestro timer no se siga ejecutando. Para ello podemos utilizar la función <b>clearTimeout</b> o <b>clearInterval</b>.
          <pre><code data-trim class="lang-javascript">
            let counter = 0;
            let timer;

            function incrementCounter() {
              counter = counter + 1;
              checkCount();
            };

            function checkCount() {
              if (counter == 10) {
                clearInterval(timer);
              };
            };

            timer = setInterval(incrementCounter, 1000);
          </code></pre>
          <aside class="notes">
            En el ejemplo las variables counter y timer son definidas antes de las funciones. Esto es para que su scope (alcence) permite utilizarlas tanto dentro como fuera de las funciones.
          </aside>
        </section>
      </section>
      
      <!-- AJAX, XHR y API fetch -->
      <section>
        <section>
          <h3>AJAX</h3>
          Es una técnica utilizada para poder cambiar contenido dinámicamente en una aplicación web. El contenido es modificado sin necesidad de recargar la página o interrumpir su comportamiento.
        </section>
        <section>
          Esto se realiza pidiendo datos a un servidor asincrónicamente. Cuando el servidor responde con los datos solicitados, se utiliza Javascript para modificar el contenido con esta nueva información.
        </section>
      </section>
      <section>
        <h3>XHR y fetch</h3>
        Se suele utilizar XHR o fetch (más moderno) para ejecutar AJAX en páginas web. <br> --- <br>
        <a target="_blank" href="https://codesandbox.io/s/restless-glade-jhwe4">CodeSandbox</a>
      </section>
      <section>
        <section>
          <h3>XHR</h3>
          Request AJAX utilizando método 'GET'
          <pre><code data-trim class="lang-javascript">
            const xhr = new XMLHttpRequest();
            xhr.open(
              "GET",
              "https://gist.githubusercontent.com/spereztoledo/d7740ac1ad1212ce8810c5c809d7acd3/raw/d57477f19d8e173b8671ffff9494db75e246d4e7/quotes.json"
            );
          
            // Rastrea sobre el request los cambio de estado
            xhr.onreadystatechange = function () {
              let DONE = 4; // readyState 4 significa que el request esta pronto.
              let OK = 200; // status 200 fue un retorno exitoso.
              if (xhr.readyState === DONE) {
                if (xhr.status === OK) {
                  // convertir respuesta a JSON ya que xhr solo responde texto o XML
                  const response = JSON.parse(xhr.responseText);
                  console.log(response);
                } else {
                  console.log("Error: " + xhr.status); // Ocurrió un error durante el request.
                }
              }
            };
          
            // Enviar el request hacia quotes.json
            xhr.send();
          </code></pre>
        </section>
        <section>
          <h3>fetch</h3>
          Fetch hace más fácil el manejo de peticiones y respuestas del servidor, en comparación con XHR.
          <pre><code data-trim class="lang-javascript">
            fetch(
              "https://gist.githubusercontent.com/spereztoledo/d7740ac1ad1212ce8810c5c809d7acd3/raw/d57477f19d8e173b8671ffff9494db75e246d4e7/quotes.json"
            )
              .then((data) => {
                console.log(data);
                return data.json();
              })
              .then((json) => console.log(json))
              .catch((error) => console.log("Error:" + error));
          </code></pre>
        </section>
      </section>
    </div>
  </div>

  <script src="../reveal.js/dist/reveal.js"></script>
  <script src="../reveal.js/plugin/notes/notes.js"></script>
  <script src="../reveal.js/plugin/markdown/markdown.js"></script>
  <script src="../reveal.js/plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>